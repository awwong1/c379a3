CMPUT 379 Assignment 3
Student: Alexander Wong
Instructor: Bob Beck

To compile:
make saucer

To run:
./saucer

User Controls:
','	to move left
'.'	to move right
' '	to fire bullet
'Q'	to quit

User Interface:
'|' 	Player
'^' 	Bullet
'<--->'	Saucer/Enemy

Game information:
Score, game information is displayed at the bottom of the window during
runtime. Goal is to shoot as many enemies down as possible before a
maximum number of enemies reach the right side of the window. You have
an unlimited number of bullets, however you are only allowed default
20 bullets on screen at one time.

Assumptions made:
Window will not be resized at anytime during the application's runtime.
Application will be run on the linux lab machines.

Code information:
My code is fundamentally an extension of the tanimate.c file, provided
to the class by Bob Beck, originally taken from grant macewan university.
The overall structure of my code consists of a setup phase, a running 
phase, and a teardown phase. 

The setup phase is responsible for instantiating all of the global 
variables, the struct values, and the threads. The running phase is 
responsible for catching user input in the main thread, and displaying
and handling the game logic in the bullet/saucer/player threads. The
teardown phase is responsible for closing created threads and displaying
the final score in the terminal window after the application exits.

I decided to use one struct, defined as 'element', to handle all the
different game objects (player, saucer, and bullet). This simplified the
implementation of creating threads, but made the animate function more
complicated than necessary. The animate function is the code which runs
in every thread except for the main thread. Every thread handles
collision detection for all structs, as I can access each object from
a global array of structs. Moreover, I have necessary mutex locks to 
handle various inputs and race conditions generated by running the game.

My mutex locks, and their necessary existance, are explained here:
collisionlock; prevents race conditions between two threads for
	       collision checking simultaneously
scorelock; prevents two threads from updating the score simultaneously,
	   mitigating a race condition
escapelock; prevents two saucers from 'escaping' the map at the same
	    time, escaping being moving from the left side of the
	    window to the right side of the window
firelock; prevents two bullets from being fired simultaneously
	  note: multiple bullets may still exist in the same location
	  if the fire button is hit rapidly enough
movelock; prevents the player thread and the user input thread from
	  having a race condition to check move inputs
drawlock; prevents multiple threads from using the cursor at the same
	  time

Because I made my array of element structs globally defined, every
thread may access it's data. Other notable globally accessed vars
include the score count, and the escape count.
The only protection for these values is the assumption that my 
application correctly uses pthread_mutex locks.

This application handles every game element in a separate thread.
Race conditions are prevented through the usage of mutex locks.
